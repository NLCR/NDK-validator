package com.logica.ndk.tm.utilities.transformation.scantailor;

import com.itextpdf.text.log.Logger;
import com.itextpdf.text.log.LoggerFactory;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import java.io.File;
import java.io.FilenameFilter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * ZT945 - samokontrola vystupu scantailor (NDKEM-24)
 *
 * Compares files which should be generated by Scan tailor.
 * Name of required files are written in the configuration file (example: 1.scanTailor).
 * Class just check if are these files located in the folder for post processing data.
 * 
 * @author krchnacekm
 */
public class ScanTailorOutputValidator {

  private static final Logger log = LoggerFactory.getLogger(ScanTailorOutputValidator.class);
  private File scanTailorConfig = null; // Scan tailor configuration file.
  private File outputDirectory = null; // Post processing data folder.
  private Document parsedScanTailorConfig; // Parsed configuration file.
  private XPath xPath; // Instance of utility for work with XPath expressions.

  /**
   * Creates validator.
   * 
   * @param scanTailorConfig
   *          Scan tailor configuration file. Mandatory argument. If configuration file is incorrect, result will be
   *          surprisingly valid with no error messages. But there will be warnings in log.
   */
  public ScanTailorOutputValidator(final File scanTailorConfig, final File outputDirectory) {
    if (scanTailorConfig != null && scanTailorConfig.exists()) {
      log.info(String.format("Scan tailor output validator will use configuration file: %s", scanTailorConfig));
      try {
        this.scanTailorConfig = scanTailorConfig;
        DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder builder = createDocumentBuilder(builderFactory);
        this.parsedScanTailorConfig = parseScanTailorConfigFile(scanTailorConfig, builder);
        this.xPath = XPathFactory.newInstance().newXPath();
        this.outputDirectory = outputDirectory;
      }
      catch (NullPointerException e) {
        log.warn(String.format("Null pointer exception during parsing of scan tailor configuration file %s. %s", scanTailorConfig, e));
      }
    }
    else {
      log.warn(String.format("Argument scanTailorConfig is mandatory and file have to exists. Value of argument is: %s.", scanTailorConfig));
    }
  }

  /**
   * Creates document builder. Class need document builder for work with xml document.
   * 
   * @param builderFactory
   *          DocumentBuilderFactory is required for creating of DocumentBuilder.
   * @return Instance of DocumentBuilder or null if creating of new instance fails.
   */
  private DocumentBuilder createDocumentBuilder(DocumentBuilderFactory builderFactory) {
    DocumentBuilder builder = null;
    try {
      builder = builderFactory.newDocumentBuilder();
    }
    catch (ParserConfigurationException e) {
      log.warn(String.format("Error during creating of document builder. %s", e));
    }
    return builder;
  }

  /**
   * Try to parse scan tailor configuration file.
   * 
   * @param scanTailorConfig
   *          Scan tailor configuration file.
   * @param builder
   *          Document builder is used for parsing configuration file.
   * @return Parsed document of null if parsing fails.
   */
  private Document parseScanTailorConfigFile(File scanTailorConfig, DocumentBuilder builder) {
    Document document = null;
    try {
      document = builder.parse(scanTailorConfig);
    }
    catch (SAXException e) {
      log.warn(String.format("Error during parsing of scan tailor configuration file. %s", e));
    }
    catch (IOException e) {
      log.warn(String.format("Error during parsing of scan tailor configuration file. %s", e));
    }
    return document;
  }

  /**
   * Compares files which should be generated by scan tailor.
   * 
   * @return ScanTailorOutputValidatorResult
   */
  public ScanTailorOutputValidatorResult checkCountOfFilesInPostProcessing() {
    final ScanTailorOutputValidatorResult result = new ScanTailorOutputValidatorResult();

    if (outputDirectory != null && outputDirectory.exists()) {
      log.info(String.format("ScanTailorOutputValidatorResult.outputDirectory: %s", outputDirectory));
      
      final String stProjectNumber = FilenameUtils.getBaseName(this.scanTailorConfig.getName());
      log.info("ScanTailor project number: " + stProjectNumber);
      FilenameFilter fileFilter = new FilenameFilter() {
			public boolean accept(File dir, String name) {
				String lowercaseName = name.toLowerCase();
				if (lowercaseName.startsWith(stProjectNumber + "_")) {
					return true;
				} else {
					return false;
				}
			}
		};
       
      final int countOfPagesInConfigFile = getCountOfPagesInConfigFile().intValue();
      final int countOfFilesInPostProcessingFolder = outputDirectory.listFiles(fileFilter).length;
      log.info("Count of files for st project number is: " + countOfFilesInPostProcessingFolder);
      
      log.info("Final values: ProjectNumber: " + stProjectNumber + ", PagesInProjectFile: " + countOfPagesInConfigFile + ", PagesInPPFolderForProject: " + countOfFilesInPostProcessingFolder);

      if (countOfPagesInConfigFile == countOfFilesInPostProcessingFolder) {
    	  log.info("Setting valid ...");
        result.setValid(true);
      }
      else {
        if (countOfFilesInPostProcessingFolder < countOfPagesInConfigFile) {
          log.warn("Error in validation of files in post processing,");
          log.debug("Setting invalid ...");
          result.setValid(false);

          List<String> fileNamesInPostProcessing = new ArrayList<String>();
          Collections.addAll(fileNamesInPostProcessing, outputDirectory.list());
          log.debug(String.format("list of files in post processing: %s\\%s", outputDirectory, fileNamesInPostProcessing));
          
          for (String page : getTiffNamesInConfigFile()) {
            if (!fileNamesInPostProcessing.contains(page)) {
              final String errorMessage = String.format("File %s\\%s is missing.", this.outputDirectory, page);
              result.getMessages().add(errorMessage);
              log.warn(errorMessage);
            }
          }
        }
      }
    }
    else {
      log.warn(String.format("Output directory is not set or doesn't exist. OutputDirectory: %s", outputDirectory));
      result.setValid(true);
      result.setMessages(new ArrayList<String>());
    }

    return result;
  }

  /**
   * Get names of Tiff files which should be in post processing data folder.
   * 
   * @return list of file names or empty list
   */
  private List<String> getTiffNamesInConfigFile() {
    final String expression = "/project/files/file";

    NodeList nodeList = null;
    try {
      nodeList = (NodeList) xPath.compile(expression).evaluate(parsedScanTailorConfig, XPathConstants.NODESET);
    }
    catch (XPathExpressionException e) {
      log.warn(String.format("Error in during evaluation of expression: %s for file: %s. Exception: %s", expression, scanTailorConfig, e));
    }

    List<String> result = new ArrayList<String>();

    if (nodeList != null) {
      for (int i = 0; i < nodeList.getLength(); i++) {
        final Node name = nodeList.item(i).getAttributes().getNamedItem("name");
        if (name != null)
          result.add(name.getTextContent());
      }
    }

    return result;
  }

  /**
   * Get count of pages in config file. This count should be equals to count of files in post processing data folder.
   * 
   * @return Count of pages.
   */
  private Double getCountOfPagesInConfigFile() {
    final String expression = "count(/project/pages/page)";

    Double result = null;
    try {
      result = (Double) xPath.compile(expression).evaluate(parsedScanTailorConfig, XPathConstants.NUMBER);
    }
    catch (XPathExpressionException e) {
      log.warn(String.format("Error in during evaluation of expression: %s for file: %s. Exception: %s", expression, scanTailorConfig, e));
    }
    log.debug("Returning number of pages in scanTailorConfigFile: " + result.intValue());
    return result;
  }

  public File getOutputDirectory() {
    return outputDirectory;
  }
}
